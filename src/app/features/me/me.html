<!-- Main content -->
<div class="hm-content mb-2">
  <div>
    <h1 style="text-align: center; color: black" nz-typography>About me: Work Experience at FSS</h1>
  </div>
</div>

<div nz-row [nzGutter]="[10, 10]">
  <div
    nz-col [nzXs]="24"
    [nzSm]="24"
    [nzMd]="24"
    [nzLg]="24"
    [nzXl]="24"
    [nzXXl]="24"
    nzOrder="1">
    <article nz-typography class="hm-content">
      <h3 style="color: royalblue">Implemented a real-time notification system</h3>
      <hr>
      <p><strong><em>Techstack:</em></strong> Angular, SpringBoot, WebSocket, Kafka, Mongodb.</p>
      <h4>Overview</h4>
      <ol>
        <li>
          Developed a real-time notification module that allows users to receive live updates and
          system alerts.
        </li>
        <li>
          Integrated the notification module with another modules to trigger real time alerts based on
          user actions
        </li>
        <li>
          Enabled automatic data refresh upon network reconnection by integrating a Spring
        </li>
        <li>
          WebSocket server that actively listens to kafka messages and pushes realtime updates
          directly to the client.
        </li>
        <li>
          Implemented unit test achieving approximately 80% coverage to ensure code quality and
          reliability.
        </li>
      </ol>
      <h3>Notable</h3>

        <h4>Kafka</h4>
        <h5 class="fst-italic">1. In a Websocket setup, each connection is one-to-one.
          A client connects directly to a specific Websocket instance and keeps that connection open.
          However, when a new message needs to be delivered to clients connected across multiple intances. It becomes necessary to broadcast the message to all of them. How can this be achieved using kafka.</h5>
        <p>I can use kafka as a message broker to distribute messages across all Websocket instances. Here's a simple approach</p>
        <ol>
          <li>Each Websocket server instance subcribes to a Kafka topic</li>
          <li>When I need to send a new message to clients, publish it to that Kafka topic instead of sending it directly to Websocket instance and any instance listening to the topic will receive the message</li>
          <li>Then each Websocket instance broadcasts the message to the clients currently connected to it</li>
          <li>I think it's also important to mention that each instance should belong to a separate groupId. Because if all wobsokcet instances use the same groupId, Kafka will load balance messages - meaning only one instance receives each message</li>
          <li>When I subcribe to a Kafka topic, I have to provide
            <ul>
              <li>Topic: the name of topic I want to listen</li>
              <li>GroupId: a unique indentifer for the consumer intance</li>
            </ul>
          </li>
        </ol>

        <h5 class="fst-italic">2. Do I have to create the topic manually, or can I just choose any name and have it created automatically if it doesn't exist?</h5>
        <p>It depends on the Kafka configuration. By default, Kafka can automatically create a topic when a producer or consumer first references a topic name that doesn't exist. But this feature is often disabled in production for safety and consistency</p>
        <ol>
          <li>If <code>auto.create.topics.enable=true</code>, Kafka will automatically create the topic when you publish or subscribe.</li>
          <li>If it's disabled, I must create the topic manually using the Kafka CLI or an Admin client</li>
        </ol>

        <h5 class="fst-italic">3. Long polling and short polling</h5>
        <p>Short polling means the client repeatedly sends request to the server at fixed intervals to check if there's new data</p>
        <p>Long polling means the client sends a request, but server keeps the connection open until there's new data to send</p>

        <h5 class="fst-italic">4. Tomcat and docker, k8s</h5>
        <p>When deploying to Tomcat, we're running the application directly on an application server</p>
        <ol>
          <li>Tomcat is a application server that actually runs the Java web application</li>
          <li>Docker, on the other hand, is just a container platform -  it provides the isolated enviroment where Tomcat runs. In other words, Tomcat executes the app logic, while Docker simply packages and runs everything as a container. In side container, i can install tomcat, nginx, mysql.. everything i need</li>
          <li>K8s is container orchestration platform. It help manages many Docker container across multiple nodes. K8s handles deployment, scaling, load balacing, rolling-update</li>
        </ol>

        <h5 class="fst-italic">5. Why I don't see Tomcat in a Spring Boot project</h5>
        <ol>
          <li>Spring boot embeds an application server by default</li>
          <li>For web apps, it usually uses embedded Tomcat, Jetty or Undertow</li>
          <li>That means I don't need to install Tomcat separately - it's already included in my spring boot Jar. And when I run <code>java -jar myapp.jar</code> Spring boot starts the embedded Tomcat server automatically and serves your app</li>
          <li>Summary:
            <ol>
              <li>Traditional WAR deployment -> I deploy to an external Tomcat server</li>
              <li>Spring Boot jar -> embedded Tomcat (or Jetty, undertow) runs inside the jar</li>
              <li>I can still package Spring boot as a WAR if you want to deploy to an external Tomcat</li>
            </ol>
          </li>
        </ol>


    </article>
  </div>
  <div nz-col
       [nzXs]="24"
       [nzSm]="24"
       [nzMd]="24"
       [nzLg]="24"
       [nzXl]="24"
       [nzXXl]="24"
    nzOrder="2"
  >
    <article nz-typography class="hm-content">
      <h3 style="color: royalblue">Custom API Gateway Authorization and Role-Based UI Rendering</h3>
      <hr>
      <p><strong><em>Techstack:</em></strong> Lua, APISIX, Postgres, Angular, KendoUI, Kubernetes</p>
      <ol>
        <li>Implemented fine-grained permission checks by querying the database functions using
          parameters such as username, API URL and HTTP method. The logic ensure that the user is
          authorized to access to service, have permission for the request function and is allowed to
          perform the specified action. Permissions are stored as bit flags, and the database function
          uses bitwise operations to quickly check if the user has all the necessary access rights.
        </li>
        <li> Deployed customize Lua Auth Plugin to k8s.</li>
        <li>Developed an API to load user context, including profile information, permission sets, and
          dynamic menu structure based on access rights.
        </li>
      </ol>
    </article>
  </div>
  <div
    nz-col
    [nzXs]="24"
    [nzSm]="24"
    [nzMd]="24"
    [nzLg]="24"
    [nzXl]="24"
    [nzXXl]="24"
    nzOrder="2">
    <article nz-typography class="hm-content">
      <h3 style="color: royalblue">About me in Angular</h3>
      <hr>
      <p><strong><em>Techstack:</em></strong> Angular, Kendo UI, Rxjs </p>
      <ol>
        <li>Designed the Angular project layout and routing with Angular router to enable modular and
          lazy-loaded navigation.
        </li>
        <li> Wrapped core Kendo UI controls to simplify developer usage, cutting development time
          and code volume by up to 90%.</li>
        <li>Built the frontend authorization flow. Call API to fetch user context including profile,
          permissions, and menu tree. Managed permisison state on the client side. Developed
          Angular directives to dynamically show or hide component UI based on user access rights..
        </li>
      </ol>
    </article>
  </div>

  <div
    nz-col
    [nzXs]="24"
    [nzSm]="24"
    [nzMd]="24"
    [nzLg]="24"
    [nzXl]="24"
    [nzXXl]="24"
    nzOrder="2">
    <article nz-typography class="hm-content">
      <h3 style="color: royalblue">Outsourcing for Bank</h3>
      <hr>
      <p><strong><em>Techstack:</em></strong>  Angular, Micro-FE, GraphQL, Spring boot </p>
      <ol>
        <li>Designed the Angular project layout and routing with Angular router to enable modular and
          lazy-loaded navigation.
        </li>
        <li> Developed an independent micro frontend and integrated it into the shell application.</li>
        <li>Developed the UI based on the clientâ€™s framework and strictly followed the provided design
          specifications.
        </li>
      </ol>
    </article>
  </div>
</div>

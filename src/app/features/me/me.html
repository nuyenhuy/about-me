<!-- Main content -->
<div class="hm-content mb-2">
  <div>
    <h1 style="text-align: center; color: black" nz-typography>About me: Work Experience at FSS</h1>
  </div>
</div>

<div nz-row [nzGutter]="[10, 10]">
  <div
    nz-col [nzXs]="24"
    [nzSm]="24"
    [nzMd]="24"
    [nzLg]="24"
    [nzXl]="24"
    [nzXXl]="24"
    nzOrder="1">
    <article nz-typography class="hm-content">
      <h3 style="color: royalblue">Implemented a real-time notification system</h3>
      <hr>
      <p><strong><em>Techstack:</em></strong> Angular, SpringBoot, WebSocket, Kafka, Mongodb.</p>
      <h4>Overview</h4>
      <ol>
        <li>
          Developed a real-time notification module that allows users to receive live updates and
          system alerts.
        </li>
        <li>
          Integrated the notification module with another modules to trigger real time alerts based on
          user actions
        </li>
        <li>
          Enabled automatic data refresh upon network reconnection by integrating a Spring
        </li>
        <li>
          WebSocket server that actively listens to kafka messages and pushes realtime updates
          directly to the client.
        </li>
        <li>
          Implemented unit test achieving approximately 80% coverage to ensure code quality and
          reliability.
        </li>
      </ol>
      <h3>Notable</h3>

        <h4>Kafka</h4>
        <h5 class="fst-italic">1. In a Websocket setup, each connection is one-to-one.
          A client connects directly to a specific Websocket instance and keeps that connection open.
          However, when a new message needs to be delivered to clients connected across multiple intances. It becomes necessary to broadcast the message to all of them. How can this be achieved using kafka.</h5>
        <p>I can use kafka as a message broker to distribute messages across all Websocket instances. Here's a simple approach</p>
        <ol>
          <li>Each Websocket server instance subcribes to a Kafka topic</li>
          <li>When I need to send a new message to clients, publish it to that Kafka topic instead of sending it directly to Websocket instance and any instance listening to the topic will receive the message</li>
          <li>Then each Websocket instance broadcasts the message to the clients currently connected to it</li>
          <li>I think it's also important to mention that each instance should belong to a separate groupId. Because if all wobsokcet instances use the same groupId, Kafka will load balance messages - meaning only one instance receives each message</li>
          <li>When I subcribe to a Kafka topic, I have to provide
            <ul>
              <li>Topic: the name of topic I want to listen</li>
              <li>GroupId: a unique indentifer for the consumer intance</li>
            </ul>
          </li>
        </ol>

        <h5 class="fst-italic">2. Do I have to create the topic manually, or can I just choose any name and have it created automatically if it doesn't exist?</h5>
        <p>It depends on the Kafka configuration. By default, Kafka can automatically create a topic when a producer or consumer first references a topic name that doesn't exist. But this feature is often disabled in production for safety and consistency</p>
        <ol>
          <li>If <code>auto.create.topics.enable=true</code>, Kafka will automatically create the topic when you publish or subscribe.</li>
          <li>If it's disabled, I must create the topic manually using the Kafka CLI or an Admin client</li>
        </ol>

        <h5 class="fst-italic">3. Long polling and short polling</h5>
        <p>Short polling means the client repeatedly sends request to the server at fixed intervals to check if there's new data</p>
        <p>Long polling means the client sends a request, but server keeps the connection open until there's new data to send</p>

        <h5 class="fst-italic">4. Tomcat and docker, k8s</h5>
        <p>When deploying to Tomcat, we're running the application directly on an application server</p>
        <ol>
          <li>Tomcat is a application server that actually runs the Java web application</li>
          <li>Docker, on the other hand, is just a container platform -  it provides the isolated enviroment where Tomcat runs. In other words, Tomcat executes the app logic, while Docker simply packages and runs everything as a container. In side container, i can install tomcat, nginx, mysql.. everything i need</li>
          <li>K8s is container orchestration platform. It help manages many Docker container across multiple nodes. K8s handles deployment, scaling, load balacing, rolling-update</li>
        </ol>

        <h5 class="fst-italic">5. Why I don't see Tomcat in a Spring Boot project</h5>
        <ol>
          <li>Spring boot embeds an application server by default</li>
          <li>For web apps, it usually uses embedded Tomcat, Jetty or Undertow</li>
          <li>That means I don't need to install Tomcat separately - it's already included in my spring boot Jar. And when I run <code>java -jar myapp.jar</code> Spring boot starts the embedded Tomcat server automatically and serves your app</li>
          <li>Summary:
            <ol>
              <li>Traditional WAR deployment -> I deploy to an external Tomcat server</li>
              <li>Spring Boot jar -> embedded Tomcat (or Jetty, undertow) runs inside the jar</li>
              <li>I can still package Spring boot as a WAR if you want to deploy to an external Tomcat</li>
            </ol>
          </li>
        </ol>

        <h5 class="fst-italic">6. What is different between websocket and socket.io</h5>
        <ol>
          <li>Websocket is the underlying technology - a communication protocol. While Socket.io is a library built on top of Websocket. That makes real-time communication easier and more reliable</li>
          <li>Websokcet
            <ol>
              <li>Sending and receiving raw messages (text, binary)</li>
              <li>No automatic reconnection, no event system, no fallback</li>
            </ol>
          </li>
          <li>Socket.io. A Javascript library (Nodejs + client-side js)
            that uses Websocket and other fallback mechanisms (like long-polling) to ensure reliable real-time communication.
            Adds many features on top of Websocket
            <ol>
              <li>Automatic reconnection</li>
              <li>Event-based communication</li>
              <li>Rooms</li>
              <li>Works even when Websocket is blocked (falls back to HTTP long-polling)</li>
            </ol>
          </li>
          <li><span class="text-black">Summary</span>(need to keep in my memmories)
            <ol>Websocket only has a few built-in events
              <li>open</li>
              <li>message</li>
              <li>error</li>
              <li>close</li>
            </ol>

            <ol>Socket.IO has its own event system - you can define named events like chat, userJoined, etc</ol>
            <div class="d-flex flex-column">
              <code>
                socket.on('chat', (data) => &#123; console.log('Chat:', data); &#125;);
              </code>
              <code>
                socket.on('userJoined', (user) => &#123; console.log('User joined:', user); &#125;);
              </code>
              <code>
                socket.emit('chat', &#123; message: 'Hi!' &#125;);
              </code>
            </div>
          </li>
        </ol>

        <h5>7. Remember to deeply understand custom event names and rooms in Socket.IO</h5>
        <ul>
          Event names - <mark>used by both client and server</mark>
          <li>are always required when sending or listening to messages. (event name = "type of message") </li>
          <p>Client side</p>
          <code>
            socket.on('chat', (data) => console.log('Got chat:', data)); // listen to 'chat' event
          </code>
          <p>Server side</p>
          <code>
            io.on('connection', (socket) => &#123;
            socket.on('chat', (data) => &#123;
            console.log('Received chat:', data);
            &#125;);
            &#125;);
          </code>
        </ul>
        <ul>
          Rooms - <mark>Used only on the server side to group clients</mark>
          <li>is just a group of connected sockets. I use rooms when I want to send a message to a specific group, not everyone</li>
          <li>Sending message to specific room: <code>io.to('room1').emit('chat', &#123; text: 'Hello room1!' &#125;);</code></li>
          <li>Sending to all connected client (including sender) <code>io.emit('chat', data);</code></li>
          <li>Sending to all connected client except sender <code> socket.broadcast.emit('chat', data);</code></li>
        </ul>
      <h5>8. Can Socket.io be used in an Angular application on the client and a Spring Boot application on the server side</h5>
      <ol>No, because Socket.io was designed for NodeJS and work best there</ol>
      <ol>If my backend is spring boot, I should use STOMP over Websocket instead. It's the officially supported and fully compatible option</ol>
      <h5>9. Does the concept of event name like in socket.io exist in STOMP. If not, is there something similar in STOMP?</h5>
      <p>No, STOMP does not have event names in the same way that Socket.IO does. STOMP replaces event names with the concept of destination (sometimes called endpoints or topics)</p>
      <ol>
        <li>
          <code>
            // Send message
            stompClient.send("/app/chat", &#123;&#125;, "Hello!");
          </code>
        </li>
        <li>
          <code>
          // Listen for message
          stompClient.subscribe("/topic/chat", message => console.log(message.body));
          </code>

        </li>
        <ul>
          <li>/app/chat is the destination to send to (server endpoint)</li>
          <li>/topic/chat is the destination to subscribe to </li>
        </ul>
      </ol>
      <h5>10. Does the concept of room like in socket.io exist in STOMP. If not, is there something similar in STOMP</h5>
      <ol>In socket.io, A room is like a group of connection clients. The server can send message only to clients in a specific room</ol>
      <ul>In STOMP
        <li>There are no rooms, but i can create different destination paths to organize my messages channels</li>
        <li>Each client chooes which destination (topic or queue) it wants to subscribe to</li>
        <ul>Some path pattern
          <li>user/&#123;userId&#125;/queue/...: only one unique user</li>
          <li>topic/group/&#123;groupId&#125;: all users in group</li>
          <li>topic/public: All connected user</li>
        </ul>
      </ul>
    </article>
  </div>
  <div nz-col
       [nzXs]="24"
       [nzSm]="24"
       [nzMd]="24"
       [nzLg]="24"
       [nzXl]="24"
       [nzXXl]="24"
    nzOrder="2"
  >
    <article nz-typography class="hm-content">
      <h3 style="color: royalblue">Custom API Gateway Authorization and Role-Based UI Rendering</h3>
      <hr>
      <p><strong><em>Techstack:</em></strong> Lua, APISIX, Postgres, Angular, KendoUI, Kubernetes</p>
      <ol>
        <li>Implemented fine-grained permission checks by querying the database functions using
          parameters such as username, API URL and HTTP method. The logic ensure that the user is
          authorized to access to service, have permission for the request function and is allowed to
          perform the specified action. Permissions are stored as bit flags, and the database function
          uses bitwise operations to quickly check if the user has all the necessary access rights.
        </li>
        <li> Deployed customize Lua Auth Plugin to k8s.</li>
        <li>Developed an API to load user context, including profile information, permission sets, and
          dynamic menu structure based on access rights.
        </li>
      </ol>
    </article>
  </div>
  <div
    nz-col
    [nzXs]="24"
    [nzSm]="24"
    [nzMd]="24"
    [nzLg]="24"
    [nzXl]="24"
    [nzXXl]="24"
    nzOrder="2">
    <article nz-typography class="hm-content">
      <h3 style="color: royalblue">About me in Angular</h3>
      <hr>
      <p><strong><em>Techstack:</em></strong> Angular, Kendo UI, Rxjs </p>
      <ol>
        <li>Designed the Angular project layout and routing with Angular router to enable modular and
          lazy-loaded navigation.
        </li>
        <li> Wrapped core Kendo UI controls to simplify developer usage, cutting development time
          and code volume by up to 90%.</li>
        <li>Built the frontend authorization flow. Call API to fetch user context including profile,
          permissions, and menu tree. Managed permisison state on the client side. Developed
          Angular directives to dynamically show or hide component UI based on user access rights..
        </li>
      </ol>
    </article>
  </div>

  <div
    nz-col
    [nzXs]="24"
    [nzSm]="24"
    [nzMd]="24"
    [nzLg]="24"
    [nzXl]="24"
    [nzXXl]="24"
    nzOrder="2">
    <article nz-typography class="hm-content">
      <h3 style="color: royalblue">Outsourcing for Bank</h3>
      <hr>
      <p><strong><em>Techstack:</em></strong>  Angular, Micro-FE, GraphQL, Spring boot </p>
      <ol>
        <li>Designed the Angular project layout and routing with Angular router to enable modular and
          lazy-loaded navigation.
        </li>
        <li> Developed an independent micro frontend and integrated it into the shell application.</li>
        <li>Developed the UI based on the clientâ€™s framework and strictly followed the provided design
          specifications.
        </li>
      </ol>
    </article>
  </div>
</div>
